# -*- coding: utf-8 -*-
"""Simulations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WLVrWc4jMV1fx6CVA8TSt5g--cW-zTQk
"""

############################################
# Begin: Define graph parameters
############################################
# The current values can be the fixed values.

random_encounters=0.01 # Probability that people meet at random, Possible values between [0,1] 
prob_commun=[0.1,.01,.01,.005,.001,0,0,0] # Possible values between [0,1] 
# First three entries are the probability meet in a community, while the last three entries is the probability of different communities meet
# Probabilities  between individuals within community 1,2,3 are represented in the entries 0,1,2,respectively.
#  Probability between individuals between community 1 and 2 are represented in entry 3
#  Probability between individuals between community 1 and 3 are represented in entry 4
#  Probability between individuals between community 2 and 3 are represented in entry 5



initial_fraction_infected = 0.08  # Percentage of the population initially infected.  Possible values between [0,1]  
fraction_interacting = 0.9 # Percentate of people interacting in each period. # Possible values between [0,1] 
p_infection = 0.1 # likelyhood that a sick people infect a healthy person (Susceptible) if they interact. 
p_contact = 0.01 # Possible values between [0,1]

import networkx as nx
import numpy as np
import matplotlib.pyplot as plt

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Mar 28 18:26:00 2020
Reimplementation of notebook from luthars and lukas from abel ideas.
@author: lg
"""
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt

def init_random(**options):
    '''Generate network according to assumed topology'''
    n = options.get('n')
    p = options.get('p')
    G = nx.erdos_renyi_graph(n, p, directed=False)
    return G

def init_stochastic_block_model(**options):
    '''Generate network according to assumed topology'''
    block_sizes = options.get('block_sizes')
    p_blocks = options.get('p_blocks')
    G = nx.generators.community.stochastic_block_model(block_sizes, p_blocks, seed=0)
    return G  

def init_barabasi_albert(**options):
    '''Generate network according to assumed topology'''
    n = options.get('n')
    k = options.get('k')
    G = nx.barabasi_albert_graph(n, k)
    return G

def network_init(network_type, **options):
    '''Generate network according to assumed topology'''
    # Choses between these models
    model_dict = {
        1: init_random,
        2: init_stochastic_block_model,
        3: init_barabasi_albert,
        }
    graph = model_dict.get(network_type, "nothing")
    return graph(**options)

def init_node_states(G, fraction_infected):
    healthy = 0
    infected = 1
#    recovered = 2
    n_infected = np.int(np.floor(fraction_infected * G.number_of_nodes()))

    # Initialize infected nodes
    # Randomly sample a subset from population corresponding to n_infected
    infected_nodes = np.random.choice(G.number_of_nodes(), n_infected, replace=False)
    state_vector = np.zeros(G.number_of_nodes()) + healthy
    state_vector[infected_nodes] = infected
    # Convert the array to dictionary of states
    state_dict = dict(enumerate(state_vector))
    
    # Initialize node states
    nx.set_node_attributes(G, state_dict, 'state')
    nx.set_node_attributes(G, 0, 'n_contacts')
    nx.set_node_attributes(G, 0, 'n_infected_contacts')
    nx.set_node_attributes(G, 0, 'infected_by')
    nx.set_node_attributes(G, 0, 'incubation_time')
    return G
    

def test_infection(p_infection):
    '''Only call function to test if infetcted person will infect a healthy one'''
    healthy = 0
    infected = 1
    return infected if np.random.random() < p_infection else healthy

def update_nodes(G, fraction_interacting, p_infection, p_contact, 
                 recovery_rate = 0, 
                 lockdown = False, people_met_in_lockdown = None, 
                 sociable = False):
    '''Set an interaction time point and update the node attributes'''
    healthy = 0
    infected = 1
    recovered = 2
    # Pick a subset of people to interact
    n_interacting = np.int(np.floor(fraction_interacting * G.number_of_nodes()))
    interacting_nodes = np.random.choice(G.number_of_nodes(), n_interacting, replace=False)
    
    # Loop only over the interacting nodes
    for i_node in interacting_nodes:
        for j_neighbor in iter(G[i_node]):
            # Test if the node meets the neighbor
            if np.random.random() < p_contact:
                # Since everyone starts with zero contacts, we can just sum up.
                G.nodes[i_node]['n_contacts'] =+ 1
                G.nodes[j_neighbor]['n_contacts'] =+ 1
                # Now if contact involves infected person
                # Since everyone starts with zero contacts, we can just sum up.
                if G.nodes[i_node]['state'] == healthy and \
                G.nodes[j_neighbor]['state'] == infected:
                    G.nodes[i_node]['n_infected_contacts'] =+ 1
                    G.nodes[i_node]['state'] = test_infection(p_infection)
                elif G.nodes[i_node]['state'] == infected and \
                G.nodes[j_neighbor]['state'] == healthy:
                    G.nodes[j_neighbor]['n_infected_contacts'] =+ 1
                    G.nodes[j_neighbor]['state'] = test_infection(p_infection)
                elif G.nodes[i_node]['state'] == infected and \
                G.nodes[j_neighbor]['state'] == infected:
                    G.nodes[i_node]['n_infected_contacts'] =+ 1
                    G.nodes[j_neighbor]['n_infected_contacts'] =+ 1        
    
    return G



# Size of the communities.
# Network size equals 300 (it is fixed.)
sizes=[100, 100, 100]

options = {
        'n': sum(sizes),
        'p': random_encounters,
        'k': 3,
        'directed': False,
        'block_sizes': sizes,
        'p_blocks': [ [prob_commun[0], prob_commun[3],prob_commun[4] ] , 
                     [prob_commun[3], prob_commun[1], prob_commun[5] ] ,
                     [prob_commun[4], prob_commun[5],prob_commun[2] ] ]}

## Parameters defining lockdown
## Fraction of people interacting each time point
#fraction_interacting = 0.1
#n_contacts = 4 # Average household size
#fraction_contact = 0.1


# Definition of states, maybe a global constant can be defined
healthy = 0
infected = 1
recovered = 2

# Number of simulation times
n_sim_times = 600

# Create random graph
G_rand_sbm = network_init(1, **options)
# Create stochastic block model
G_sbm = network_init(2, **options)
# Add block connections to random graph
G_rand_sbm.add_edges_from(G_sbm.edges())
G_rand_sbm = G_rand_sbm.to_undirected()

n_infected = np.zeros(n_sim_times)

# Initialize network
G = init_node_states(G_rand_sbm, fraction_infected=initial_fraction_infected)
# Extract node states, will make a method
states = np.array(list(nx.get_node_attributes(G, 'state').values()))

n_infected = np.zeros(n_sim_times)
n_infected1 = np.zeros(n_sim_times)
n_infected2 = np.zeros(n_sim_times)
n_infected3 = np.zeros(n_sim_times)

infected_tem= np.size(np.where(states == infected))
n_infected[0] =infected_tem
states1 =states[range(0,sizes[0]-1)]
states2 =states[range(sizes[0],sizes[0]+sizes[1]-1)]
states3 =states[range(sizes[0]+sizes[1],sizes[0]+sizes[1]+sizes[2]-1)]

n_infected1[0] =np.size(np.where(states1 == infected))
n_infected2[0] =np.size(np.where(states2 == infected))
n_infected3[0] =np.size(np.where(states3 == infected))

# Run the simulation assuming one timestep per day
for i_time in np.arange(1, n_sim_times):
    G = update_nodes(G, fraction_interacting=fraction_interacting, 
                 p_infection=p_infection, p_contact=p_contact)
    # Extract node states, will make a method
    states = np.array(list(nx.get_node_attributes(G, 'state').values()))
    n_infected[i_time] = np.size(np.where(states == infected))
    states1 =states[range(0,sizes[0]-1)]
    states2 =states[range(sizes[0],sizes[0]+sizes[1]-1)]
    states3 =states[range(sizes[0]+sizes[1],sizes[0]+sizes[1]+sizes[2]-1)]

    n_infected1[i_time] =np.size(np.where(states1 == infected))
    n_infected2[i_time] =np.size(np.where(states2 == infected))
    n_infected3[i_time] =np.size(np.where(states3 == infected))

    #nx.draw_spring(G, cmap=plt.get_cmap('viridis'), node_color=states)
n_infected_adj=n_infected/sum(sizes)
n_infected_adj1=n_infected1/sizes[0]
n_infected_adj2=n_infected2/sizes[1]
n_infected_adj3=n_infected3/sizes[2]

plt.plot(n_infected_adj, color='black')    # Everyone
plt.plot(n_infected_adj1,color='red')      # Community 1
plt.plot(n_infected_adj2,color='green')    # Community 2
plt.plot(n_infected_adj3,color='yellow')   # Community 3
plt.xlabel('Time step (days)')
plt.ylabel('Percentage of  of infected people by community')

selected_nodes = [n for n,v in G.nodes(data=True) if v['state'] == 1]  
G_sub=G.subgraph(selected_nodes)
state=list(nx.get_node_attributes(G_sub,'state'))
nx.draw(G_sub, node_color=state)



import json

with open('data.json', 'w') as outfile:
    json.dump(nx.node_link_data(G), outfile)



